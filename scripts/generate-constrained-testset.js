#!/usr/bin/env node

/**
 * Generate a constrained test set with explicit metrics and LLM narratives
 *
 * This script generates scenarios where:
 * 1. ALL key metrics are explicitly generated for every scenario
 * 2. Ground truth is calculated using the formula
 * 3. Narratives are generated by LLM with metric constraints
 *
 * Usage:
 *   node scripts/generate-constrained-testset.js --name constrained-v1 --size 10
 *
 * Options:
 *   --name         Test set name (required)
 *   --description  Description of the test set
 *   --size         Number of scenarios (default: 15)
 *   --seed         Random seed for reproducibility (default: random)
 *   --no-narrative Skip LLM narrative generation (use fallback)
 *   --model        Model for narrative generation (default: openai/gpt-4o-mini)
 */

const fs = require('fs').promises;
const path = require('path');
const { v4: uuidv4 } = require('uuid');

// Parse command line arguments
const args = process.argv.slice(2);
const getArg = (name, defaultValue) => {
  const index = args.indexOf(`--${name}`);
  if (index === -1) return defaultValue;
  return args[index + 1] || defaultValue;
};
const hasFlag = (name) => args.includes(`--${name}`);

const config = {
  name: getArg('name', null),
  description: getArg('description', 'Constrained test set with explicit metrics for formula-based evaluation'),
  size: parseInt(getArg('size', '15')),
  seed: parseInt(getArg('seed', Date.now().toString())),
  useNarrative: !hasFlag('no-narrative'),
  narrativeModel: getArg('model', 'openai/gpt-4o-mini'),
};

if (!config.name) {
  console.error('Error: --name is required');
  console.log('\nUsage: node scripts/generate-constrained-testset.js --name constrained-v1 [options]');
  console.log('\nOptions:');
  console.log('  --name         Test set name (required)');
  console.log('  --description  Description of the test set');
  console.log('  --size         Number of scenarios (default: 15)');
  console.log('  --seed         Random seed for reproducibility');
  console.log('  --no-narrative Skip LLM narrative generation');
  console.log('  --model        Model for narrative generation (default: openai/gpt-4o-mini)');
  process.exit(1);
}

// Seeded random number generator
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = Math.sin(s) * 10000;
    return s - Math.floor(s);
  };
}

// Formula coefficients
const FORMULA_COEFFICIENTS = {
  nrr: {
    worldClass: { threshold: 130, adjustment: 15 },
    excellent: { threshold: 120, adjustment: 10 },
    good: { threshold: 110, adjustment: 5 },
    concerning: { threshold: 100, adjustment: -10 },
    critical: { threshold: 90, adjustment: -20 },
  },
  marketExpansion: 12,
  marketContraction: -15,
  salesTeamDoubled: 10,
  salesChallenges: -12,
  quotaAttainmentThreshold: 50,
  macroHeadwind: -8,
  macroTailwind: 6,
  productLaunch: 8,
  pricePressure: -6,
};

// Base rates by anchor
const ANCHOR_BASE_RATES = {
  saas_startup_growth: 85,
  saas_scaleup_growth: 55,
  saas_enterprise_growth: 25,
  ecommerce_startup: 120,
  ecommerce_scaleup: 45,
  ecommerce_enterprise: 15,
  fintech_startup: 100,
  fintech_scaleup: 50,
  fintech_enterprise: 20,
  healthcare_startup: 70,
  healthcare_scaleup: 35,
  manufacturing_smb: 8,
  manufacturing_enterprise: 4,
  retail_smb: 12,
  retail_enterprise: 5,
  consulting_smb: 18,
  consulting_enterprise: 8,
};

// Anchor descriptions for narrative generation
const ANCHOR_DESCRIPTIONS = {
  saas_startup_growth: "SaaS Startup (Seed/Series A, <$5M ARR)",
  saas_scaleup_growth: "SaaS Scale-up (Series B/C, $5M-$50M ARR)",
  saas_enterprise_growth: "SaaS Enterprise ($50M+ ARR, mature)",
  ecommerce_startup: "E-commerce Startup (early stage, high growth potential)",
  ecommerce_scaleup: "E-commerce Scale-up (established, $10M-$100M revenue)",
  ecommerce_enterprise: "E-commerce Enterprise ($100M+ revenue, market leader)",
  fintech_startup: "Fintech Startup (pre-Series B, regulatory approval in progress)",
  fintech_scaleup: "Fintech Scale-up (licensed, $20M-$100M revenue)",
  fintech_enterprise: "Fintech Enterprise ($100M+ revenue, established market position)",
  healthcare_startup: "Healthcare Tech Startup (digital health, early clinical traction)",
  healthcare_scaleup: "Healthcare Scale-up (FDA cleared/CE marked, growing sales)",
  manufacturing_smb: "Manufacturing SMB (traditional, $5M-$50M revenue)",
  manufacturing_enterprise: "Manufacturing Enterprise ($100M+ revenue, industrial)",
  retail_smb: "Retail SMB (physical stores, regional presence)",
  retail_enterprise: "Retail Enterprise (national chain, mature market)",
  consulting_smb: "Professional Services SMB (consulting, $2M-$20M revenue)",
  consulting_enterprise: "Professional Services Enterprise (Big 4 level, stable growth)",
};

// Complete metric ranges per anchor - ALL scenarios get ALL relevant metrics
const ANCHOR_METRIC_RANGES = {
  saas_startup_growth: {
    arr: { min: 0.5, max: 5 },
    nrr: { min: 85, max: 150 },
    grossRetention: { min: 80, max: 95 },
    customerCount: { min: 10, max: 100 },
    acv: { min: 5, max: 100 },
    salesCycleMonths: { min: 1, max: 6 },
    quotaAttainment: { min: 40, max: 90 },
    salesTeamSize: { min: 2, max: 15 },
  },
  saas_scaleup_growth: {
    arr: { min: 5, max: 50 },
    nrr: { min: 85, max: 140 },
    grossRetention: { min: 85, max: 95 },
    customerCount: { min: 50, max: 500 },
    acv: { min: 20, max: 500 },
    salesCycleMonths: { min: 3, max: 12 },
    quotaAttainment: { min: 30, max: 95 },
    salesTeamSize: { min: 10, max: 100 },
  },
  saas_enterprise_growth: {
    arr: { min: 50, max: 500 },
    nrr: { min: 100, max: 130 },
    grossRetention: { min: 90, max: 98 },
    customerCount: { min: 200, max: 2000 },
    acv: { min: 100, max: 2000 },
    salesCycleMonths: { min: 6, max: 18 },
    quotaAttainment: { min: 50, max: 90 },
    salesTeamSize: { min: 50, max: 500 },
  },
  ecommerce_startup: {
    revenue: { min: 1, max: 10 },
    nrr: { min: 70, max: 130 },
    grossRetention: { min: 60, max: 85 },
    customerCount: { min: 1000, max: 50000 },
    aov: { min: 30, max: 200 },
    conversionRate: { min: 1, max: 5 },
    quotaAttainment: { min: 40, max: 90 },
    salesTeamSize: { min: 3, max: 20 },
  },
  ecommerce_scaleup: {
    revenue: { min: 10, max: 100 },
    nrr: { min: 80, max: 125 },
    grossRetention: { min: 70, max: 90 },
    customerCount: { min: 50000, max: 500000 },
    aov: { min: 40, max: 300 },
    conversionRate: { min: 2, max: 6 },
    quotaAttainment: { min: 50, max: 85 },
    salesTeamSize: { min: 15, max: 100 },
  },
  ecommerce_enterprise: {
    revenue: { min: 100, max: 1000 },
    nrr: { min: 85, max: 115 },
    grossRetention: { min: 75, max: 92 },
    customerCount: { min: 500000, max: 10000000 },
    aov: { min: 50, max: 400 },
    conversionRate: { min: 2, max: 8 },
    quotaAttainment: { min: 55, max: 85 },
    salesTeamSize: { min: 50, max: 500 },
  },
  fintech_startup: {
    arr: { min: 0.1, max: 5 },
    nrr: { min: 90, max: 145 },
    grossRetention: { min: 85, max: 95 },
    customerCount: { min: 100, max: 10000 },
    acv: { min: 0.5, max: 50 },
    quotaAttainment: { min: 40, max: 85 },
    salesTeamSize: { min: 3, max: 25 },
  },
  fintech_scaleup: {
    arr: { min: 20, max: 100 },
    nrr: { min: 95, max: 140 },
    grossRetention: { min: 88, max: 96 },
    customerCount: { min: 10000, max: 500000 },
    acv: { min: 0.5, max: 20 },
    quotaAttainment: { min: 45, max: 90 },
    salesTeamSize: { min: 20, max: 150 },
  },
  fintech_enterprise: {
    arr: { min: 100, max: 500 },
    nrr: { min: 100, max: 130 },
    grossRetention: { min: 92, max: 98 },
    customerCount: { min: 100000, max: 5000000 },
    acv: { min: 1, max: 50 },
    quotaAttainment: { min: 55, max: 85 },
    salesTeamSize: { min: 100, max: 800 },
  },
  healthcare_startup: {
    arr: { min: 0, max: 5 },
    nrr: { min: 95, max: 150 },
    grossRetention: { min: 90, max: 98 },
    customerCount: { min: 5, max: 50 },
    acv: { min: 50, max: 500 },
    salesCycleMonths: { min: 6, max: 18 },
    quotaAttainment: { min: 35, max: 80 },
    salesTeamSize: { min: 2, max: 15 },
  },
  healthcare_scaleup: {
    arr: { min: 5, max: 100 },
    nrr: { min: 105, max: 145 },
    grossRetention: { min: 92, max: 98 },
    customerCount: { min: 50, max: 500 },
    acv: { min: 100, max: 1000 },
    salesCycleMonths: { min: 6, max: 24 },
    quotaAttainment: { min: 45, max: 85 },
    salesTeamSize: { min: 10, max: 80 },
  },
  manufacturing_smb: {
    revenue: { min: 5, max: 50 },
    nrr: { min: 90, max: 130 },
    grossRetention: { min: 85, max: 95 },
    customerCount: { min: 20, max: 200 },
    acv: { min: 50, max: 500 },
    quotaAttainment: { min: 50, max: 90 },
    salesTeamSize: { min: 3, max: 20 },
  },
  manufacturing_enterprise: {
    revenue: { min: 100, max: 1000 },
    nrr: { min: 95, max: 120 },
    grossRetention: { min: 90, max: 98 },
    customerCount: { min: 50, max: 500 },
    acv: { min: 200, max: 5000 },
    quotaAttainment: { min: 55, max: 85 },
    salesTeamSize: { min: 20, max: 200 },
  },
  retail_smb: {
    revenue: { min: 2, max: 50 },
    nrr: { min: 75, max: 115 },
    grossRetention: { min: 70, max: 90 },
    customerCount: { min: 5000, max: 100000 },
    aov: { min: 20, max: 150 },
    quotaAttainment: { min: 45, max: 85 },
    salesTeamSize: { min: 5, max: 30 },
  },
  retail_enterprise: {
    revenue: { min: 100, max: 5000 },
    nrr: { min: 80, max: 110 },
    grossRetention: { min: 75, max: 92 },
    customerCount: { min: 100000, max: 10000000 },
    aov: { min: 30, max: 200 },
    quotaAttainment: { min: 55, max: 85 },
    salesTeamSize: { min: 50, max: 500 },
  },
  consulting_smb: {
    revenue: { min: 2, max: 20 },
    nrr: { min: 85, max: 130 },
    grossRetention: { min: 80, max: 95 },
    customerCount: { min: 10, max: 100 },
    acv: { min: 50, max: 500 },
    quotaAttainment: { min: 50, max: 90 },
    salesTeamSize: { min: 2, max: 15 },
  },
  consulting_enterprise: {
    revenue: { min: 50, max: 500 },
    nrr: { min: 90, max: 120 },
    grossRetention: { min: 85, max: 95 },
    customerCount: { min: 100, max: 1000 },
    acv: { min: 200, max: 5000 },
    quotaAttainment: { min: 55, max: 85 },
    salesTeamSize: { min: 30, max: 300 },
  },
};

// Delta configurations - how they modify metrics
const DELTAS = {
  strong_nrr: { nrrOverride: { min: 130, max: 150 } },
  weak_nrr: { nrrOverride: { min: 75, max: 89 } },
  market_expansion: { marketExpansion: true },
  market_contraction: { marketContraction: true },
  strong_sales_team: { salesTeamGrowth: { min: 100, max: 200 } },
  sales_challenges: { quotaAttainmentOverride: { min: 20, max: 45 } },
  product_innovation: { productLaunchImminent: true },
  economic_tailwind: { macroEnvironment: 'tailwind' },
  economic_headwind: { macroEnvironment: 'headwind' },
  price_pressure: { pricePressure: true },
};

// Distractors
const DISTRACTORS = [
  "The company recently moved to a new headquarters with modern amenities.",
  "The CEO was featured in a prominent industry publication last quarter.",
  "The company has a popular employee wellness program.",
  "The founding team met at a prestigious university.",
  "The company sponsors a local sports team.",
  "The office has an award-winning interior design.",
  "The company was named one of the best places to work regionally.",
  "The CFO previously worked at a Fortune 500 company.",
  "The company has a strong social media presence.",
  "The annual company retreat is held at a luxury resort.",
];

function calculateNrrAdjustment(nrr) {
  if (nrr === undefined) return 0;
  const { worldClass, excellent, good, concerning, critical } = FORMULA_COEFFICIENTS.nrr;
  if (nrr >= worldClass.threshold) return worldClass.adjustment;
  if (nrr >= excellent.threshold) return excellent.adjustment;
  if (nrr >= good.threshold) return good.adjustment;
  if (nrr < critical.threshold) return critical.adjustment;
  if (nrr < concerning.threshold) return concerning.adjustment;
  return 0;
}

function calculateGrowthRate(anchorKey, metrics) {
  const baseRate = ANCHOR_BASE_RATES[anchorKey];
  if (baseRate === undefined) {
    throw new Error(`Unknown anchor: ${anchorKey}`);
  }

  const adjustments = [];
  let total = baseRate;

  // NRR adjustment
  const nrrAdj = calculateNrrAdjustment(metrics.nrr);
  if (nrrAdj !== 0) {
    adjustments.push({ name: `NRR ${metrics.nrr}%`, value: nrrAdj });
    total += nrrAdj;
  }

  // Market expansion
  if (metrics.marketExpansion) {
    adjustments.push({ name: "Market expansion", value: FORMULA_COEFFICIENTS.marketExpansion });
    total += FORMULA_COEFFICIENTS.marketExpansion;
  }

  // Market contraction
  if (metrics.marketContraction) {
    adjustments.push({ name: "Market contraction", value: FORMULA_COEFFICIENTS.marketContraction });
    total += FORMULA_COEFFICIENTS.marketContraction;
  }

  // Sales team growth
  if (metrics.salesTeamGrowth && metrics.salesTeamGrowth >= 100) {
    adjustments.push({ name: "Sales team doubled", value: FORMULA_COEFFICIENTS.salesTeamDoubled });
    total += FORMULA_COEFFICIENTS.salesTeamDoubled;
  }

  // Sales challenges
  if (metrics.quotaAttainment !== undefined && metrics.quotaAttainment < FORMULA_COEFFICIENTS.quotaAttainmentThreshold) {
    adjustments.push({ name: `Sales challenges (${metrics.quotaAttainment}% quota)`, value: FORMULA_COEFFICIENTS.salesChallenges });
    total += FORMULA_COEFFICIENTS.salesChallenges;
  }

  // Macro environment
  if (metrics.macroEnvironment === "headwind") {
    adjustments.push({ name: "Macro headwind", value: FORMULA_COEFFICIENTS.macroHeadwind });
    total += FORMULA_COEFFICIENTS.macroHeadwind;
  }
  if (metrics.macroEnvironment === "tailwind") {
    adjustments.push({ name: "Macro tailwind", value: FORMULA_COEFFICIENTS.macroTailwind });
    total += FORMULA_COEFFICIENTS.macroTailwind;
  }

  // Product launch
  if (metrics.productLaunchImminent) {
    adjustments.push({ name: "Product launch", value: FORMULA_COEFFICIENTS.productLaunch });
    total += FORMULA_COEFFICIENTS.productLaunch;
  }

  // Price pressure
  if (metrics.pricePressure) {
    adjustments.push({ name: "Price pressure", value: FORMULA_COEFFICIENTS.pricePressure });
    total += FORMULA_COEFFICIENTS.pricePressure;
  }

  // Build calculation string
  const calcParts = [`Base (${anchorKey}): ${baseRate}%`];
  for (const adj of adjustments) {
    const sign = adj.value >= 0 ? "+" : "";
    calcParts.push(`${adj.name}: ${sign}${adj.value}%`);
  }
  calcParts.push(`Final: ${total}%`);

  return {
    value: total,
    calculation: calcParts.join("\n"),
  };
}

function generateMetrics(anchorKey, deltaKeys, random) {
  const ranges = ANCHOR_METRIC_RANGES[anchorKey];
  if (!ranges) {
    throw new Error(`No metric ranges defined for anchor: ${anchorKey}`);
  }

  const metrics = {};

  // Helper to generate value within range
  const inRange = (range) => {
    if (!range) return undefined;
    return range.min + random() * (range.max - range.min);
  };

  // Generate ALL base metrics from ranges
  if (ranges.arr !== undefined) metrics.arr = Math.round(inRange(ranges.arr) * 10) / 10;
  if (ranges.revenue !== undefined) metrics.revenue = Math.round(inRange(ranges.revenue) * 10) / 10;
  if (ranges.nrr !== undefined) metrics.nrr = Math.round(inRange(ranges.nrr));
  if (ranges.grossRetention !== undefined) metrics.grossRetention = Math.round(inRange(ranges.grossRetention));
  if (ranges.customerCount !== undefined) metrics.customerCount = Math.round(inRange(ranges.customerCount));
  if (ranges.acv !== undefined) metrics.acv = Math.round(inRange(ranges.acv));
  if (ranges.aov !== undefined) metrics.aov = Math.round(inRange(ranges.aov));
  if (ranges.salesCycleMonths !== undefined) metrics.salesCycleMonths = Math.round(inRange(ranges.salesCycleMonths));
  if (ranges.quotaAttainment !== undefined) metrics.quotaAttainment = Math.round(inRange(ranges.quotaAttainment));
  if (ranges.salesTeamSize !== undefined) metrics.salesTeamSize = Math.round(inRange(ranges.salesTeamSize));
  if (ranges.conversionRate !== undefined) metrics.conversionRate = Math.round(inRange(ranges.conversionRate) * 10) / 10;

  // Apply delta modifiers
  for (const deltaKey of deltaKeys) {
    const delta = DELTAS[deltaKey];
    if (!delta) continue;

    if (delta.nrrOverride) {
      metrics.nrr = Math.round(inRange(delta.nrrOverride));
    }
    if (delta.marketExpansion) {
      metrics.marketExpansion = true;
    }
    if (delta.marketContraction) {
      metrics.marketContraction = true;
    }
    if (delta.salesTeamGrowth) {
      metrics.salesTeamGrowth = Math.round(inRange(delta.salesTeamGrowth));
    }
    if (delta.quotaAttainmentOverride) {
      metrics.quotaAttainment = Math.round(inRange(delta.quotaAttainmentOverride));
    }
    if (delta.productLaunchImminent) {
      metrics.productLaunchImminent = true;
    }
    if (delta.macroEnvironment) {
      metrics.macroEnvironment = delta.macroEnvironment;
    }
    if (delta.pricePressure) {
      metrics.pricePressure = true;
    }
  }

  return metrics;
}

function formatMetricsForNarrative(metrics) {
  const lines = [];

  // Revenue metrics
  if (metrics.arr !== undefined) {
    lines.push(`- Annual Recurring Revenue (ARR): $${metrics.arr}M`);
  }
  if (metrics.revenue !== undefined) {
    lines.push(`- Annual Revenue: $${metrics.revenue}M`);
  }

  // Retention metrics
  if (metrics.nrr !== undefined) {
    lines.push(`- Net Revenue Retention (NRR): ${metrics.nrr}%`);
  }
  if (metrics.grossRetention !== undefined) {
    lines.push(`- Gross Revenue Retention: ${metrics.grossRetention}%`);
  }

  // Customer metrics
  if (metrics.customerCount !== undefined) {
    lines.push(`- Customer Count: ${metrics.customerCount.toLocaleString()}`);
  }
  if (metrics.acv !== undefined) {
    lines.push(`- Average Contract Value (ACV): $${metrics.acv}K`);
  }
  if (metrics.aov !== undefined) {
    lines.push(`- Average Order Value (AOV): $${metrics.aov}`);
  }

  // Sales metrics
  if (metrics.salesCycleMonths !== undefined) {
    lines.push(`- Sales Cycle Length: ${metrics.salesCycleMonths} months`);
  }
  if (metrics.quotaAttainment !== undefined) {
    lines.push(`- Sales Quota Attainment: ${metrics.quotaAttainment}%`);
  }
  if (metrics.salesTeamSize !== undefined) {
    lines.push(`- Sales Team Size: ${metrics.salesTeamSize} reps`);
  }
  if (metrics.salesTeamGrowth !== undefined) {
    lines.push(`- Sales Team Growth (YoY): ${metrics.salesTeamGrowth}%`);
  }
  if (metrics.conversionRate !== undefined) {
    lines.push(`- Conversion Rate: ${metrics.conversionRate}%`);
  }

  // Market/macro factors
  if (metrics.marketExpansion) {
    lines.push(`- Currently expanding into new geographic markets`);
  }
  if (metrics.marketContraction) {
    lines.push(`- Recently exited or consolidated geographic markets`);
  }
  if (metrics.macroEnvironment === "headwind") {
    lines.push(`- Industry facing macroeconomic pressure`);
  }
  if (metrics.macroEnvironment === "tailwind") {
    lines.push(`- Industry benefiting from macroeconomic tailwinds`);
  }

  // Product factors
  if (metrics.productLaunchImminent) {
    lines.push(`- Major product launch or platform expansion imminent`);
  }
  if (metrics.pricePressure) {
    lines.push(`- Facing pricing pressure from competition`);
  }

  return lines.join('\n');
}

function generateFallbackNarrative(anchorKey, metrics, distractors) {
  const parts = [];
  parts.push(`## Company Profile\n`);
  parts.push(`*Investment memo summary*\n`);
  parts.push(`Company Type: ${ANCHOR_DESCRIPTIONS[anchorKey] || anchorKey}\n`);
  parts.push(`\n**Key Metrics:**`);
  parts.push(formatMetricsForNarrative(metrics));

  if (distractors.length > 0) {
    parts.push(`\n**Additional Context:**`);
    for (const d of distractors) {
      parts.push(`- ${d}`);
    }
  }

  return parts.join('\n');
}

async function generateLLMNarrative(anchorKey, metrics, distractors, seed, apiKey, model) {
  const metricsText = formatMetricsForNarrative(metrics);
  
  const prompt = `You are an equity research analyst writing an investment memo for a private company.

Generate a detailed company profile that includes the EXACT metrics specified below. The metrics MUST appear in the narrative exactly as provided - do not change, round, or approximate them.

REQUIRED METRICS (these MUST appear exactly as specified):
${metricsText}

COMPANY TYPE: ${ANCHOR_DESCRIPTIONS[anchorKey] || anchorKey}

${distractors.length > 0 ? `DISTRACTORS (include these naturally but they should NOT affect growth assessment):\n${distractors.map(d => `- ${d}`).join('\n')}` : ''}

FORMAT REQUIREMENTS:
1. Write a professional investment memo (400-600 words)
2. Include ALL required metrics with their EXACT values
3. Create a realistic company name and founding story
4. Include team composition and funding history
5. Describe market position and competition
6. Do NOT include any growth rate estimates or predictions
7. Make it read like an authentic investment memo

Use random seed ${seed} for variation in company name, location, and other non-metric details.

Generate the company profile now:`;

  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
      'HTTP-Referer': 'https://estimate-playground.local',
    },
    body: JSON.stringify({
      model: model,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.8,
      max_tokens: 2048,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`OpenRouter API error: ${response.status} - ${error}`);
  }

  const data = await response.json();
  return data.choices[0].message.content.trim();
}

async function generateTestSet() {
  console.log('Generating constrained test set with configuration:');
  console.log(JSON.stringify(config, null, 2));
  console.log('');

  // Check for API key if using narratives
  const apiKey = process.env.OPENROUTER_API_KEY;
  if (config.useNarrative && !apiKey) {
    console.error('Error: OPENROUTER_API_KEY environment variable is required for narrative generation');
    console.log('Set it with: export OPENROUTER_API_KEY=your_key');
    console.log('Or use --no-narrative to skip LLM narrative generation');
    process.exit(1);
  }

  const random = seededRandom(config.seed);

  // Available anchors for testing (use a good mix)
  const anchors = [
    'saas_startup_growth',
    'saas_scaleup_growth', 
    'saas_enterprise_growth',
    'fintech_scaleup',
    'ecommerce_enterprise',
    'healthcare_startup',
    'manufacturing_smb',
  ];

  // Available deltas
  const deltaKeys = Object.keys(DELTAS);

  const scenarios = [];

  for (let i = 0; i < config.size; i++) {
    console.log(`Generating scenario ${i + 1}/${config.size}...`);
    
    // Select random anchor
    const anchorKey = anchors[Math.floor(random() * anchors.length)];

    // Select 0-2 random deltas
    const numDeltas = Math.floor(random() * 3);
    const selectedDeltas = [];
    const shuffledDeltas = [...deltaKeys].sort(() => random() - 0.5);
    for (let j = 0; j < numDeltas && j < shuffledDeltas.length; j++) {
      selectedDeltas.push(shuffledDeltas[j]);
    }

    // Select 0-1 distractors
    const numDistractors = Math.floor(random() * 2);
    const selectedDistractors = [];
    const shuffledDistractors = [...DISTRACTORS].sort(() => random() - 0.5);
    for (let j = 0; j < numDistractors && j < shuffledDistractors.length; j++) {
      selectedDistractors.push(shuffledDistractors[j]);
    }

    // Generate ALL metrics for this anchor
    const metrics = generateMetrics(anchorKey, selectedDeltas, random);

    // Calculate ground truth using formula
    const { value, calculation } = calculateGrowthRate(anchorKey, metrics);

    // Generate narrative
    let narrative;
    if (config.useNarrative) {
      try {
        narrative = await generateLLMNarrative(
          anchorKey, 
          metrics, 
          selectedDistractors, 
          Math.floor(random() * 1000000),
          apiKey,
          config.narrativeModel
        );
        console.log(`  ✓ Generated LLM narrative for ${anchorKey}`);
      } catch (error) {
        console.error(`  ✗ Failed to generate narrative: ${error.message}`);
        narrative = generateFallbackNarrative(anchorKey, metrics, selectedDistractors);
      }
      
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 500));
    } else {
      narrative = generateFallbackNarrative(anchorKey, metrics, selectedDistractors);
    }

    // Calculate tolerance (10% of absolute value, min 5)
    const tolerance = Math.max(5, Math.abs(value) * 0.1);

    scenarios.push({
      id: uuidv4(),
      anchor: anchorKey,
      appliedDeltas: selectedDeltas,
      distractors: selectedDistractors,
      contextDescription: narrative,
      metrics: metrics,
      groundTruth: {
        value: value,
        tolerance: tolerance,
        calculation: calculation,
      },
    });
  }

  const testSet = {
    name: config.name,
    version: "1.0.0",
    description: config.description,
    created: new Date().toISOString(),
    domainId: "financial-forecasting",
    scenarioCount: scenarios.length,
    seed: config.seed,
    generateTwins: false,
    useNarrativeDescriptions: config.useNarrative,
    narrativeModel: config.useNarrative ? config.narrativeModel : undefined,
    useConstrainedMetrics: true,
    scenarios: scenarios,
  };

  // Save to file
  const outputPath = path.join(__dirname, '..', 'data', 'test-sets', `${config.name}.json`);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, JSON.stringify(testSet, null, 2));

  console.log('');
  console.log('✅ Constrained test set created successfully!');
  console.log('');
  console.log(`Name: ${testSet.name}`);
  console.log(`Version: ${testSet.version}`);
  console.log(`Scenarios: ${testSet.scenarioCount}`);
  console.log(`Seed: ${testSet.seed}`);
  console.log(`Narratives: ${config.useNarrative ? `LLM (${config.narrativeModel})` : 'Fallback'}`);
  console.log('');
  console.log(`Saved to: data/test-sets/${testSet.name}.json`);
  console.log('');
  
  // Show sample metrics
  console.log('Sample scenario metrics:');
  console.log(JSON.stringify(scenarios[0].metrics, null, 2));
  console.log('');
  console.log('Sample ground truth:');
  console.log(scenarios[0].groundTruth.calculation);
  console.log('');
  console.log('Next steps:');
  console.log(`  node scripts/run-testset.js --testset ${testSet.name} --model <model> --prompt persona`);
}

generateTestSet().catch(console.error);
